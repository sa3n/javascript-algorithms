// REQUIREMENTS:

const arr = require('./sample-data/array')
// const sortedArr = require('./sample-data/sorted_array')
// const { adjacencyMatrix } = require('./sample-data/graph')
// const tree = require('./sample-data/tree')

// SOLUTIONS:

// SORTING
// console.log(bubbleSort(arr)) // +
// console.log(insertionSort(arr)) // с вырезанием +
// console.log(selectionSort(arr)) // со свопами +
// console.log(quickSort(arr)) // +
// console.log(mergeSort(arr)) // +

// SEARCHING
// console.log(binarySearch(sortedArr, 14)) // 3 +

// RECURSION
// fib: с рекурсией без оптимизации
// fib: итеративно
// fib: хвостовая рекурсия с мемоизацией +
// fib: с кешированием +
// console.log(fib(4)) // 5 +
// console.log(fib(5)) // 8 +
// generateBrackets(3) -!!!
// console.dir(towerOfHanoi(5, rods[0], rods[2], rods[1]), { depth: Infinity }) // +
// console.log(rods)

// DATA STRUCTURES
// LinkedList // insert, delete, display, search, update +
// Stack // push, pop, pick +
// Queue // enqueue, dequeue, pick +
// ещё не готовы! Binary Tree - // isLeaf, hasChildren НЕ ЗАКОНЧИЛ! нужно дописать!!!
// ещё не готовы! Binary Heap -

// ---------

// TREES
// treeDFS(tree.root) // 1 2 4 5 6 7 8 3 -
// treeBFS(tree.root) // 1 2 3 4 5 6 7 8 - ДОПИСАТЬ УРОВНИ!

// MATH
// Sieve of Eratosphenes

// GRAPHS
// DFS
// BFS
// console.log(dijkstra(adjacencyMatrix, 0)) // [0, 5, 2, 9, 7, 8]
// dijkstra: быстрее, чем за квадрта!


// STRINGS
// console.log(wagnerFischer('abcde', 'nfbc')) // 4
// console.log(wagnerFischer('kitten', 'hitting')) // 3
